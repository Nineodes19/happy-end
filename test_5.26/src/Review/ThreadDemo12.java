package Review;

/**
 * @program:test_5.26
 * @author:Nine_odes
 * @description:
 * @create:2020-05-26 10:42
 **/

/**
 * 多个线程并发式的修改同一个数据的时候，此时就可能导致最终结果不可预期==》线程不安全问题（万恶之源：抢占式执行）
 *线程不安全的原因：
 * 1.【万恶之源】抢占式执行，抢占式导致两个线程之间的具体并行情况无法预知，最终结果就难以预知
 * 2.修改同一个数据
 *      a ）如果是每个线程修改自己的数据，相互不打架，那就没问题
 *      b)多线程读取同一个数据，但是不修改，也没问题
 *  3.++ 操作不是原子的。如果多个线程之间的修改操作都是原子的话，就不受到影响了。
 *
 *  原子的：多个操作绑定到一起，要么都不执行，要么保证都能执行完，并且执行过程中不会被干扰
 *  4.内存可见性
 *       每个线程都有一个自己的工作内存，整体所有线程共享一个主内存
 *       线程工作的时候，一般会先把主内存的数据拷贝到工作内存中，再去进行操作
 *       数据在主内存和工作内存之间3相互拷贝过程中也会说道多线程的影响
 *       当线程1来修改count的失手，会先把count从主内存拷贝到线程1的工作内存中，再在
 *       线程1的工作内存中进行修改count，修改完了需要把这个数据拷贝回主内存。
 *
 *       如果线程1改了count之后还没来得及拷贝数据回主内存
 *       线程2就从主内存之读取count值了，此时同样会引发线程不安全问题。
 *  5.指令重排序（JVM对指令优化的效果）
 *       原则上讲，优化不应该影响原有的逻辑
 *       但是在多线程情况下，这个是不容易保证的
 *
 *          重排序：在不影响整体逻辑的前提下，调整指令执行的先后顺序，
 *              达到提升执行效率的目的，完全是由编译器自己控制的
 */
public class ThreadDemo12 {
    static class Counter{
        public int count = 0;

        //英文原意：同步----》互斥
        //使用这个关键字能给某段代码加锁（同一时刻只有一个线程能访问到）
        //进入方法的时候会加锁。方法结束的时候会释放
        //互斥锁：同一时刻只有一个线程能够获得锁，其他线程想要获取锁，就必须等待
        //      直到刚才的线程释放了锁，才有机会得到

        //线程2获取锁的时候，发现锁已经被线程1占有了，线程2 就会等待
        //一直等到线程1释放锁，线程2才有可能获取到锁继续往下执行
        //“可能”是因为等待这把锁的线程可能有很多，线程2不一定能在
        //线程12释放之后就立刻获取锁，线程2可能会陷入一个漫长的等待

        //如果某个程序涉及到锁，基本上就和“高性能”无缘了
        //另外，加锁解锁操作也会触发主内存和工作内存之间的数据拷贝，
        //可以保证两种内存之间的数据能够被及时同步
        //
        //加锁本质上是让锁内部的代码具备原子性，不会受到其他线程影响

        /**
         * synchronized这个关键字使用时的一些细节~
         * 加锁的时候必须需要指定某个对象（对谁进行加锁）
         * 1.关键字加到普通方法前面，锁的是this对象
         * 2.关键字加到静态方法前面，锁的是当前的类对象
         *      类对象，.class文件加载到内存中所对应的对象
         *      描述了某个类具体的结构（类的图纸）---》
         *          描述了这个类中有哪些属性，每个属性都叫啥是啥类型，访问权限
         *          描述这个类中有哪些方法，每个方法叫什么，每个方法的参数和返回值类型，访问权限
         *          描述了这个类中有哪些构造方法，每个方法的参数是什么，访问权限
         *      在JVM的方法区之中
         *
         * 3.通过“同步代码块”来指定锁哪个对象
         *      对象头可以理解为每个对象内置的一些属性
         *      对象头中有一个专门的标记位来描述锁的状态、
         *      对象头标记位只是java中对于锁应用程序层面上的视线，如果进一步往底层深究，
         *  锁的实现一定是基于“硬件支持”（CPU会提供一些加锁解锁的相关指令）
         *
         */
        synchronized public void increase(){
            /**
             * 一次自增操作其实可以分成三个步骤：
             * 1.CPU要从内存中读取count的值（load）
             * 2.在CPU内部对这个数据进行+1（计算结果在CPU的寄存器中）
             * 3.把计算结果从寄存器写回到内存中
             */
            count++;
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Counter counter = new Counter();
        //匿名内部类
        Thread t1 = new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 50000; i++) {
                    counter.increase();
                }
            }
        };
        t1.start();

        Thread t2 = new Thread(){
            @Override
            public void run() {
                for (int i = 0; i < 50000; i++) {
                    counter.increase();
                }
            }
        };
        t2.start();

        t1.join();
        t2.join();
        System.out.println(counter.count);
    }
}
